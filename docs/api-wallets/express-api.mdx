---
title: "Express API"
description: "Simplified wallet management API with built-in key management. Create wallets and sign transactions for EVM, Solana, and Bitcoin with minimal setup."
---

## Overview

Magic's Express API is a streamlined wallet management solution designed for rapid development and deployment. Express API provides non-custodial wallet functionality using trusted execution environment technology, allowing you to focus on building your application while maintaining full control over your private keys.

### Key Benefits

- **Non-custodial security**: Your private keys remain under your control using TEE technology
- **Multi-chain support**: EVM chains, Solana, and Bitcoin
- **Simple authentication**: JWT-based user authentication
- **Rapid development**: Get started in minutes, not hours, with production-ready infrastructure
- **Enterprise security**: AWS Nitro TEE protection for all operations

### Base URL

All API requests should be made to:

```
https://tee.express.magiclabs.com
```

<Info>
Express API is a production-ready solution for applications that need wallet functionality with non-custodial security. It's designed for both rapid development and enterprise-scale applications that require full control over private keys while leveraging Magic's secure infrastructure.
</Info>

<Tip>
Express API uses AWS Nitro TEE technology to ensure your private keys are never exposed to Magic or any third party, maintaining true non-custodial security while providing enterprise-grade infrastructure.
</Tip>

## Getting Started

### Prerequisites

Before using Express API, you'll need:

1. **Magic Developer Account**: Sign up at [Magic Dashboard](https://dashboard.magic.link/)
2. **Application Setup**: Create a new application in your dashboard
3. **OIDC Provider**: Configure an OIDC provider for user authentication
4. **API Keys**: Obtain your Magic API key or secret key

<Steps>
<Step title="Create Magic Account">
Visit [https://dashboard.magic.link/](https://dashboard.magic.link/) and sign up for a Magic developer account.
</Step>

<Step title="Create Application">
In your dashboard, create a new application and note your API keys.
</Step>

<Step title="Configure OIDC Provider">
Set up an OIDC provider (like Auth0, Firebase Auth, or custom) for user authentication.
</Step>

<Step title="Get Your API Keys">
Obtain your Magic API key or secret key from your dashboard for service authentication.
</Step>
</Steps>

## Authentication

Express API requires multiple authentication headers for secure access:

<ParamField header="Authorization" type="string" required>
Bearer token (JWT) for user authentication. Format: `Bearer YOUR_JWT_TOKEN`
</ParamField>

<ParamField header="X-Magic-API-Key" type="string">
Your Magic API key for service authentication.
</ParamField>

<ParamField header="X-Magic-Secret-Key" type="string">
Alternative to API key - your Magic secret key for service authentication.
</ParamField>

<ParamField header="X-OIDC-Provider-ID" type="string" required>
The OIDC provider ID for your application.
</ParamField>

<Warning>
You must provide either `X-Magic-API-Key` or `X-Magic-Secret-Key` along with the other required headers.
</Warning>

<Tip>
The JWT token should contain user identification information that Magic can use to associate wallets with specific users. Ensure your OIDC provider is configured to include necessary user claims.
</Tip>

## Wallet Management

### Get or Create Wallet

Get or create a wallet for the given chain and return its public address. If a wallet doesn't exist for the user and chain combination, one will be created automatically.

```bash cURL icon="square-terminal"
curl -X POST 'https://tee.express.magiclabs.com/v1/wallet' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjNhYVl5dGR3d2UwMzJzMXIzVElyOSJ9...' \
  -H 'X-Magic-API-Key: your-magic-api-key' \
  -H 'X-OIDC-Provider-ID: your-oidc-provider-id' \
  -d '{
    "chain": "ETH"
  }'
```

**Response:**

```json
{
  "public_address": "0x6b422EefBFBc47a6900A1fc5454Ef4b940B7e36e"
}
```

<ParamField body="chain" type="string" required>
The blockchain to create the wallet for. Available values: `ETH`, `SOL`, `BTC`
</ParamField>

<ResponseField name="public_address" type="string">
The wallet's public address on the specified blockchain.
</ResponseField>

<Info>
Each user can have one wallet per blockchain. Calling this endpoint multiple times with the same user and chain will return the same wallet address.
</Info>

## Signing Operations

### Sign Data

Sign a hash of arbitrary data using the wallet's private key. This is useful for signing transaction data, typed data, or any structured information.

```bash cURL icon="square-terminal"
curl -X POST 'https://tee.express.magiclabs.com/v1/wallet/sign/data' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjNhYVl5dGR3d2UwMzJzMXIzVElyOSJ9...' \
  -H 'X-Magic-API-Key: your-magic-api-key' \
  -H 'X-OIDC-Provider-ID: your-oidc-provider-id' \
  -d '{
    "chain": "ETH",
    "raw_data_hash": "0xabc123def4567890abc123def4567890abc123def4567890abc123def4567890"
  }'
```

**Response:**

```json
{
  "message_hash": "0xabc123def4567890abc123def4567890abc123def4567890abc123def4567890",
  "signature": "0x8e7d6c5b4a3928172635445566778899aabbccddeeff00112233445566778899",
  "r": "0x3d4e5f678901234567890abcdef1234567890abcdef1234567890abcdef1234",
  "s": "0x4e5f678901234567890abcdef1234567890abcdef1234567890abcdef123456",
  "v": "27"
}
```

<ParamField body="chain" type="string" required>
The blockchain to sign for. Available values: `ETH`, `SOL`, `BTC`
</ParamField>

<ParamField body="raw_data_hash" type="string" required>
The keccak256 hash of the data to sign (hex string with 0x prefix).
</ParamField>

<ResponseField name="message_hash" type="string">
The hash that was signed.
</ResponseField>

<ResponseField name="signature" type="string">
The complete signature in hex format.
</ResponseField>

<ResponseField name="r" type="string">
The r component of the ECDSA signature.
</ResponseField>

<ResponseField name="s" type="string">
The s component of the ECDSA signature.
</ResponseField>

<ResponseField name="v" type="string">
The recovery parameter of the ECDSA signature.
</ResponseField>

### Sign Message

Sign an arbitrary message using the wallet's private key. Useful for authentication, off-chain verification, and personal signatures.

```bash cURL icon="square-terminal"
curl -X POST 'https://tee.express.magiclabs.com/v1/wallet/sign/message' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjNhYVl5dGR3d2UwMzJzMXIzVElyOSJ9...' \
  -H 'X-Magic-API-Key: your-magic-api-key' \
  -H 'X-OIDC-Provider-ID: your-oidc-provider-id' \
  -d '{
    "chain": "ETH",
    "message_base64": "bm9uZQ=="
  }'
```

**Response:**

```json
{
  "signature": "0x0cebb670d8375ac74122b46c44def7e1ce593e80434a3e6557108ae124f8b44f3c5068fc104279fe7f51918cbe4c249d707bc1c0ce2fdee8d",
  "r": "0x0cebb670d8375ac74122b46c44def7e1ce593e80434a3e6557108ae124f8b44f",
  "s": "0x3c5068fc104279fe7f51918cbe4c249d707bc1c0ce2fdee8d",
  "v": "27"
}
```

<ParamField body="chain" type="string" required>
The blockchain to sign for. Available values: `ETH`, `SOL`, `BTC`
</ParamField>

<ParamField body="message_base64" type="string" required>
The message to sign, encoded as base64.
</ParamField>

<ResponseField name="signature" type="string">
The complete signature in hex format.
</ResponseField>

<ResponseField name="r" type="string">
The r component of the ECDSA signature.
</ResponseField>

<ResponseField name="s" type="string">
The s component of the ECDSA signature.
</ResponseField>

<ResponseField name="v" type="string">
The recovery parameter of the ECDSA signature.
</ResponseField>

## Data Preparation

When signing messages or data, you need to properly encode your data:

### Message Signing

For signing messages (personal signatures), encode your data as base64:

```javascript JavaScript icon="square-js"
const personalSign = async (data: string) => {
  const message = Buffer.from(data, 'utf-8').toString('base64');
  const body = { message_base64: message, chain: 'ETH' };
  return await fetch('/v1/wallet/sign/message', { 
    method: 'POST', 
    body: JSON.stringify(body) 
  });
};
```

### Data Signing

For signing transaction data or other structured data, provide a keccak256 hash:

<CodeGroup>
```javascript Typed Data V1
import { typedSignatureHash } from '@metamask/eth-sig-util';

const signTypedDataV1 = async (data: TypedDataV1) => {
  const rawDataHash = typedSignatureHash(data);
  const body = { raw_data_hash: rawDataHash, chain: 'ETH' };
  return await fetch('/v1/wallet/sign/data', { 
    method: 'POST', 
    body: JSON.stringify(body) 
  });
};
```

```javascript Typed Data V3/V4
import {
  MessageTypes,
  SignTypedDataVersion,
  TypedDataUtils,
  TypedMessage,
} from '@metamask/eth-sig-util';

const computeEip712Hash = (
  data: TypedMessage<MessageTypes>,
  version: SignTypedDataVersion.V3 | SignTypedDataVersion.V4,
): string => {
  const hashBuffer = TypedDataUtils.eip712Hash(data, version);
  return '0x' + hashBuffer.toString('hex');
};

const signTypedDataV3 = async (data: TypedMessage<MessageTypes>) => {
  const rawDataHash = computeEip712Hash(data, SignTypedDataVersion.V3);
  const body = { raw_data_hash: rawDataHash, chain: 'ETH' };
  return await fetch('/v1/wallet/sign/data', { 
    method: 'POST', 
    body: JSON.stringify(body) 
  });
};

const signTypedDataV4 = async (data: TypedMessage<MessageTypes>) => {
  const rawDataHash = computeEip712Hash(data, SignTypedDataVersion.V4);
  const body = { raw_data_hash: rawDataHash, chain: 'ETH' };
  return await fetch('/v1/wallet/sign/data', { 
    method: 'POST', 
    body: JSON.stringify(body) 
  });
};
```

```javascript Transaction Signing
import { resolveProperties, Signature, Transaction, TransactionLike, TransactionRequest } from 'ethers';

const signTransaction = async (tx: TransactionRequest) => {
  const resolvedTx = await resolveProperties(tx);
  const txForSigning = { ...resolvedTx };
  delete txForSigning.from;

  const btx = Transaction.from(txForSigning as TransactionLike);

  const body = { raw_data_hash: btx.unsignedHash, chain: 'ETH' };
  const res = await fetch('/v1/wallet/sign/data', { 
    method: 'POST', 
    body: JSON.stringify(body) 
  });
  const { r, s, v } = res.json();
  btx.signature = Signature.from({ r, s, v });
  return btx.serialized;
};
```
</CodeGroup>

## Use Cases

<CardGroup cols={2}>
<Card title="Direct Frontend Integration" icon="rocket">
Perfect for client-side applications that authenticate users with JWTs and call Express API directly from the browser or mobile app.
</Card>

<Card title="Backend Proxy Pattern" icon="server">
Ideal for server-side applications that receive user JWTs from frontend clients and proxy requests to Express API for enhanced security and control.
</Card>

<Card title="Non-Custodial Applications" icon="shield">
Perfect for applications that need non-custodial wallet security while leveraging secure infrastructure, such as DeFi protocols or self-custody solutions.
</Card>

<Card title="Multi-Chain Support" icon="link">
Support Ethereum, Solana, and Bitcoin with a single API integration.
</Card>
</CardGroup>

## Error Handling

Express API uses standard HTTP status codes and returns detailed error information for validation errors:

### Validation Error (422)

```json
{
  "detail": [
    {
      "loc": ["string", 0],
      "msg": "string", 
      "type": "string"
    }
  ]
}
```

<ResponseField name="detail" type="array">
Array of validation error details.

<Expandable title="Error detail properties">
  <ResponseField name="loc" type="array">
  Location of the error in the request (path to the invalid field).
  </ResponseField>
  
  <ResponseField name="msg" type="string">
  Human-readable error message.
  </ResponseField>
  
  <ResponseField name="type" type="string">
  Machine-readable error type identifier.
  </ResponseField>
</Expandable>
</ResponseField>

### Common Error Scenarios

**401 Unauthorized**
- Invalid or expired JWT token
- Missing or invalid API key/secret key
- Invalid OIDC provider ID

**422 Unprocessable Entity**
- Invalid chain parameter
- Malformed hash format
- Invalid base64 encoding

**500 Internal Server Error**
- Server-side processing errors
- Contact Magic support if persistent

<Tip>
Always implement proper error handling in your application:
- Check HTTP status codes before processing responses
- Log error details for debugging
- Provide meaningful error messages to your users
- Implement retry logic for transient errors
</Tip>