---
title: "Core API"
description: "Server-side wallet management API with AWS Nitro TEE security. Create, manage, and sign transactions for EVM, Solana, and Bitcoin wallets without client-side dependencies."
---

## Overview

Magic's Core API is a server-side wallet management solution that provides enterprise-grade security through AWS Nitro Trusted Execution Environment (TEE). Unlike traditional wallet solutions, Core API operates entirely server-side, giving you complete control over your wallet infrastructure while maintaining the highest security standards.

### Key Benefits

- **Server-side only**: No client-side dependencies, iframes, or local sessions
- **Multi-chain support**: EVM chains, Solana, and Bitcoin
- **Enterprise security**: AWS Nitro TEE protection for all key operations
- **Flexible architecture**: Integrate with any tech stack
- **Key sharding**: Advanced cryptographic key management

### Base URL

All API requests should be made to:

```
https://tee.magiclabs.com
```

<Info>
Core API is designed for developers who need maximum control over their wallet infrastructure. It's ideal for applications requiring custom key management, compliance with specific regulations, or integration with existing backend systems.
</Info>

<Warning>
Core API provides the tools for both custodial and non-custodial implementations. The choice depends on how you manage the `encryption_context` and key shards. Consult legal professionals about custodial vs non-custodial distinctions in your target markets.
</Warning>

## Getting Started

### Prerequisites

Before using Core API, you'll need:

1. **Magic Developer Account**: Sign up at [Magic Dashboard](https://dashboard.magic.link/)
2. **Application Setup**: Create a new application in your dashboard
3. **API Key Allowlisting**: Contact Magic to allowlist your `Publishable API Key`
4. **Secret Key**: Use your `Secret Key` for API authentication

<Steps>
<Step title="Create Magic Account">
Visit [https://dashboard.magic.link/](https://dashboard.magic.link/) and sign up for a Magic developer account.
</Step>

<Step title="Create Application">
In your dashboard, create a new application and note your `Publishable API Key`.
</Step>

<Step title="Configure Allowlisting">
In your Magic dashboard, go to **Settings** â†’ **Allowed Origins & Redirects** to configure domain allowlisting for Core API access.
</Step>

<Step title="Get Your Secret Key">
Once allowlisted, you'll receive your `Secret Key` (format: `sk_live_XXXXXXXX`) for API authentication.
</Step>
</Steps>

<Frame>
<img src="/images/api-wallets-core-getting-started.webp" alt="Magic Dashboard showing API key configuration" />
</Frame>

## Authentication

Core API requires authentication using your Magic secret key:

<ParamField header="x-magic-secret-key" type="string" required>
Your Magic secret key for service authentication. Format: `sk_live_XXXXXXXX`
</ParamField>

<Warning>
This secret key should be treated as extremely sensitive, as it would allow anyone to trigger the creation of a wallet and return the access and recovery key.
</Warning>

## Security Architecture

### AWS Nitro Trusted Execution Environment

Core API leverages AWS Nitro TEE to provide hardware-level security for all cryptographic operations. This ensures that:

- Private keys are never exposed in plaintext
- All cryptographic operations happen in an isolated, tamper-proof environment
- Even Magic cannot access your private keys without proper authorization

### Key Sharding System

Core API uses advanced cryptographic key sharding to distribute private key material across multiple components, ensuring no single entity has complete access to your wallets.

<Frame>
<img src="/images/api-wallets-core-shard-diagram.webp" alt="Diagram showing how private keys are split into 5 shards for security" />
</Frame>

#### How Key Sharding Works

When a wallet is created, the private key is split using a **2-of-3 threshold scheme**:

<CardGroup cols={2}>
<Card title="Shard 1 (Magic)" icon="shield">
Always available from Magic's secure infrastructure. Used for all key operations including recovery.
</Card>

<Card title="Shard 2 (Recovery Key)" icon="key">
Returned to your application. Store securely in your database. Used only for wallet recovery when `encryption_context` is lost.
</Card>

<Card title="Shard 3 (Encrypted)" icon="lock">
Encrypted with your `encryption_context` and split into Shards 4 & 5. Required for all non-recovery operations.
</Card>

<Card title="Shard 4 (Access Key)" icon="database">
Returned to your application. Store securely in your database. Combined with Shard 5 to recreate Shard 3.
</Card>

<Card title="Shard 5 (Magic)" icon="shield">
Always available from Magic's secure infrastructure. Used with Shard 4 to recreate Shard 3.
</Card>
</CardGroup>

#### Operation Types

**Non-Recovery Operations** (Signing transactions, messages)
- Uses: Shard 1 + Shard 3 (recreated from Shards 4 + 5 + `encryption_context`)
- Requires: User's `encryption_context` + stored `access_key`

**Recovery Operations** (When `encryption_context` is lost)
- Uses: Shard 1 + Shard 2
- Requires: Stored `recovery_key`
- Updates: All shard values with new `encryption_context`

### Custodial vs Non-Custodial Implementation

<Warning>
Magic does not act as a custodian of your or your users' digital assets. Ownership and control remain entirely with you and your users. Consult legal professionals about custodial vs non-custodial distinctions in your target markets.
</Warning>

The implementation type depends on how you manage the `encryption_context`:

**Non-Custodial Approach:**
- `encryption_context` is derived from user input (e.g., passphrase, biometric data)
- User must provide `encryption_context` for each operation
- Application cannot perform operations without user consent

**Custodial Approach:**
- `encryption_context` is managed by your application
- Application can perform operations on behalf of users
- Requires careful consideration of user consent and regulatory compliance

<Tip>
For non-custodial implementations, consider using user-derived `encryption_context` such as:
- User-entered passphrase (hashed)
- Biometric data
- Hardware security module (HSM) keys
- Multi-party computation (MPC) protocols
</Tip>

## Implementation Patterns

### Wallet Generation Flow

<Frame>
<img src="/images/example-wallet-generation-flow-diagram.webp" alt="Flow diagram showing client-server wallet creation process" />
</Frame>

This flow shows how to securely create a wallet using user-provided `encryption_context`:

1. **Client**: User enters passphrase/biometric data
2. **Client**: Hash the user input to create `encryption_context`
3. **Client**: Send `encryption_context` to your server
4. **Server**: Call Core API to create wallet with `encryption_context`
5. **Server**: Store `access_key` and `recovery_key` securely
6. **Client**: Display wallet address to user

<Tip>
Always hash user input before using it as `encryption_context`. Never send raw user data to Core API.
</Tip>

### Non-Recovery Key Operation Flow

<Frame>
<img src="/images/example-non-recovery-key-operation-flow-diagram.webp" alt="Flow diagram showing client-server key signing process" />
</Frame>

This flow shows how to sign transactions using the user's `encryption_context`:

1. **Client**: User initiates transaction (e.g., transfer tokens)
2. **Client**: User re-enters passphrase/biometric data
3. **Client**: Hash the user input to recreate `encryption_context`
4. **Client**: Send transaction + `encryption_context` to server
5. **Server**: Retrieve stored `access_key` from database
6. **Server**: Call Core API to sign transaction
7. **Server**: Broadcast signed transaction to blockchain

### Recovery Flow

<Frame>
<img src="/images/example-recovery-flow-diagram.webp" alt="Flow diagram showing client-server wallet recovery process" />
</Frame>

This flow shows how to recover a wallet when the original `encryption_context` is lost:

1. **Client**: User indicates they've forgotten their passphrase
2. **Client**: User enters new passphrase/biometric data
3. **Client**: Hash the new input to create new `encryption_context`
4. **Client**: Send new `encryption_context` to server
5. **Server**: Retrieve stored `recovery_key` from database
6. **Server**: Call Core API recovery endpoint
7. **Server**: Update stored keys with new `access_key` and `recovery_key`

<Warning>
Recovery operations update all key shards. Ensure you have proper backup procedures before initiating recovery.
</Warning>

### Common Use Cases

<CardGroup cols={2}>
<Card title="DeFi Applications" icon="coins">
Create wallets for users to interact with DeFi protocols. Users maintain control through passphrase-based `encryption_context`.
</Card>

<Card title="NFT Marketplaces" icon="image">
Enable users to create wallets for NFT trading while maintaining non-custodial control over their assets.
</Card>

<Card title="Enterprise Solutions" icon="building">
Build custodial solutions for businesses managing crypto assets on behalf of customers or employees.
</Card>

<Card title="Cross-Chain Bridges" icon="link">
Support multiple blockchain networks (EVM, Solana, Bitcoin) with unified wallet management.
</Card>
</CardGroup>

## API Reference

### Wallet Groups

Wallet groups allow you to logically organize wallets for better management and organization.

#### Create Wallet Group

Creates a new wallet group for organizing wallets.
```bash cURL icon="square-terminal"
curl -X POST 'https://tee.magiclabs.com/v1/api/wallet_group' \
  -H 'Content-Type: application/json' \
  -H 'x-magic-secret-key: sk_live_XXXXXXXX' \
  -d '{
    "metadata": {
      "resource_id": "customer-resource-id"
    }'
```

**Response:**

```json
{
  "data": {
    "uuid": "7313a996-eb9c-4568-acef-f622a6b151fd",
    "time_created": 1709931542,
    "time_updated": 1709931542,
    "metadata": {
      "resource_id": "customer-resource-id"
    }
  }
}
```
<ParamField body="metadata.resource_id" type="string">
Optional identifier for the wallet group. Useful for organizing wallets by customer, project, or environment.
</ParamField>

<ResponseField name="data.uuid" type="string">
Unique identifier for the created wallet group. Use this when creating wallets.
</ResponseField>

<ResponseField name="data.time_created" type="integer">
Unix timestamp (UTC) when the wallet group was created.
</ResponseField>

<ResponseField name="data.time_updated" type="integer">
Unix timestamp (UTC) when the wallet group was last updated.
</ResponseField>

#### List Wallet Groups

Retrieve all wallet groups for your application.
```bash cURL icon="square-terminal"
curl -X GET 'https://tee.magiclabs.com/v1/api/wallet_groups' \
  -H 'x-magic-secret-key: sk_live_XXXXXXXX'
```

**Response:**

```json
{
  "data": [
    {
      "uuid": "7313a996-eb9c-4568-acef-f622a6b151fd",
      "time_created": 1709931542,
      "time_updated": 1718035165,
      "metadata": {
        "resource_id": "customer-resource-id"
      }
    }
  ]
}
```
<ResponseField name="data" type="array">
Array of wallet group objects, each containing the same fields as the create response.
</ResponseField>

### Wallet Management

#### Create Wallet

Create a new wallet for a user. Returns the `recovery_key`, `access_key`, and wallet `uuid` for future operations.
```bash cURL icon="square-terminal"
curl -X POST 'https://tee.magiclabs.com/v1/api/wallet' \
  -H 'Content-Type: application/json' \
  -H 'x-magic-secret-key: sk_live_XXXXXXXX' \
  -d '{
    "encryption_context": "hashed_passcode",
    "network": "mainnet",
    "wallet_group_id": "58a08494-3c83-439a-8a07-551f2022c3fc",
    "metadata": {
      "resource_id": "customer-resource-id"
    }
  }'
```

```json
{
  "data": {
    "uuid": "e982b4a3-14d3-4d66-a3ac-fadfc3ae1875",
    "time_created": 1709931542,
    "time_updated": null,
    "network": "mainnet",
    "wallet_group_id": "58a08494-3c83-439a-8a07-551f2022c3fc",
    "metadata": {
      "resource_id": "customer-resource-id"
    },
    "key_type": "CORE",
    "public_address": "0x797063FB2e3C31a8b9a10D7EDF6dE612d6aE7Fde",
    "recovery_key": "3130cc5b8fb4c5a835067f8c1aba3872",
    "access_key": "ebf0e16c5c22cd734083c803562b5dc0"
  }
}
```
<ParamField body="encryption_context" type="string" required>
The context used to encrypt key shards. Should be derived from user input (e.g., hashed passphrase).
</ParamField>

<ParamField body="network" type="string" required>
Target blockchain network. Values: `BTC_MAINNET`, `BTC_TESTNET`, `BTC_REGTEST` for Bitcoin; `SOL_MAINNET`, `SOL_TESTNET` for Solana; all other values create EVM wallet.
</ParamField>

<ParamField body="wallet_group_id" type="string">
UUID of the wallet group to organize this wallet under.
</ParamField>

<ParamField body="metadata.resource_id" type="string">
Optional identifier for the wallet (e.g., user ID, customer ID).
</ParamField>

<ResponseField name="data.uuid" type="string">
Unique wallet identifier. Use this for all subsequent operations.
</ResponseField>

<ResponseField name="data.public_address" type="string">
The wallet's public address on the specified network.
</ResponseField>

<ResponseField name="data.recovery_key" type="string">
Key shard for wallet recovery. Store securely in your database.
</ResponseField>

<ResponseField name="data.access_key" type="string">
Key shard for non-recovery operations. Store securely in your database.
</ResponseField>

<Warning>
Store both `recovery_key` and `access_key` securely in your database. These are required for wallet operations and recovery.
</Warning>

### Transaction Signing

Sign transaction payloads for different blockchain networks. The payload format varies by network type.

#### EVM Transaction Signing

Sign Ethereum and EVM-compatible chain transactions.
```bash cURL icon="square-terminal"
curl -X POST 'https://tee.magiclabs.com/v1/api/wallet/sign_transaction' \
  -H 'Content-Type: application/json' \
  -H 'x-magic-secret-key: sk_live_XXXXXXXX' \
  -d '{
    "payload": {
      "type": 2,
      "chainId": 888888,
      "nonce": 1,
      "value": "0x616263646566",
      "gas": 100000,
      "maxFeePerGas": 2000000000,
      "maxPriorityFeePerGas": 2000000000,
      "to": "0x0aA818d7952c0B6a56ee97581708866C154f63AD"
    },
    "encryption_context": "hashed_passcode",
    "access_key": "key_shard",
    "wallet_id": "wallet_id"
  }'
```
#### Solana Transaction Signing

Sign Solana blockchain transactions.
```bash cURL icon="square-terminal"
curl -X POST 'https://tee.magiclabs.com/v1/api/wallet/sign_transaction' \
  -H 'Content-Type: application/json' \
  -H 'x-magic-secret-key: sk_live_XXXXXXXX' \
  -d '{
    "payload": "transaction_base64",
    "encryption_context": "hashed_passcode",
    "access_key": "key_shard",
    "wallet_id": "wallet_id"
  }'
```
#### Bitcoin Transaction Signing

Sign Bitcoin blockchain transactions.
```bash cURL icon="square-terminal"
curl -X POST 'https://tee.magiclabs.com/v1/api/wallet/sign_transaction' \
  -H 'Content-Type: application/json' \
  -H 'x-magic-secret-key: sk_live_XXXXXXXX' \
  -d '{
    "payload": {
      "inputs": [
        {
          "address": "bc1q59ehj6mza09gk8v5558dqpy8m4c...",
          "value": 5,
          "txid": "d12beb629cebe086149c9c7b558f09531f8...",
          "tx_num": 0
        }
      ],
      "outputs": [
        {
          "address": "bc1q59ehj6mza09gk8v5558dqpy8m4c...",
          "value": 5
        }
      ]
    },
    "encryption_context": "hashed_passcode",
    "access_key": "key_shard",
    "wallet_id": "wallet_id"
  }'
```

```json
{
  "data": {
    "signed_transaction": "0xabc...",
    "transaction_hash": "0xabc..."
  }
}
```
<ParamField body="payload" type="object" required>
Transaction payload to be signed. Format varies by network:
- **EVM**: Standard Ethereum transaction object
- **Solana**: Base64-encoded transaction string
- **Bitcoin**: Object with inputs and outputs arrays
</ParamField>

<ParamField body="encryption_context" type="string" required>
The encryption context used to decrypt key shards. Must match the context used during wallet creation.
</ParamField>

<ParamField body="access_key" type="string" required>
The access key returned from wallet creation. Retrieve from your database.
</ParamField>

<ParamField body="wallet_id" type="string" required>
The wallet UUID returned from wallet creation.
</ParamField>

<ResponseField name="data.signed_transaction" type="string">
The signed transaction ready for broadcast to the blockchain.
</ResponseField>

<ResponseField name="data.transaction_hash" type="string">
The transaction hash that will be generated when the transaction is submitted to the network.
</ResponseField>

### Sign Data

Sign arbitrary data using keccak256 hash.
```bash cURL icon="square-terminal"
curl -X POST 'https://tee.magiclabs.com/v1/api/wallet/sign_data' \
  -H 'Content-Type: application/json' \
  -H 'x-magic-secret-key: sk_live_XXXXXXXX' \
  -d '{
    "raw_data_hash": "keccak256_string_hash",
    "encryption_context": "hashed_passcode",
    "access_key": "key_shard",
    "wallet_id": "wallet_id"
  }'
```

```json
{
  "data": {
    "messageHash": "0xabc...",
    "signature": "0xabc...",
    "r": "",
    "s": "",
    "v": ""
  }
}
```
<ParamField body="raw_data_hash" type="string" required>
The keccak256 hash of the data to sign
</ParamField>

<ParamField body="encryption_context" type="string" required>
The encryption context used to decrypt key shards. Must match the context used during wallet creation.
</ParamField>

<ParamField body="access_key" type="string" required>
The access key returned from wallet creation. Retrieve from your database.
</ParamField>

<ParamField body="wallet_id" type="string" required>
The wallet UUID returned from wallet creation.
</ParamField>

<ResponseField name="data.messageHash" type="string">
The hash that was signed
</ResponseField>

<ResponseField name="data.signature" type="string">
The complete signature in hex format
</ResponseField>

<ResponseField name="data.r" type="string">
The r component of the ECDSA signature
</ResponseField>

<ResponseField name="data.s" type="string">
The s component of the ECDSA signature
</ResponseField>

<ResponseField name="data.v" type="string">
The recovery parameter of the ECDSA signature
</ResponseField>

### Sign Message (Solana)

Sign an arbitrary message using a Solana wallet.
```bash cURL icon="square-terminal"
curl -X POST 'https://tee.magiclabs.com/v1/api/wallet/svm/sign_message' \
  -H 'Content-Type: application/json' \
  -H 'x-magic-secret-key: sk_live_XXXXXXXX' \
  -d '{
    "message_base64": "base64_string_hash",
    "encryption_context": "hashed_passcode",
    "access_key": "key_shard",
    "wallet_id": "wallet_id"
  }'
```

```json
{
  "data": {
    "signature": "base64_encoded"
  }
}
```
<ParamField body="message_base64" type="string" required>
The message to be signed, encoded in base64
</ParamField>

<ParamField body="encryption_context" type="string" required>
The encryption context used to decrypt key shards. Must match the context used during wallet creation.
</ParamField>

<ParamField body="access_key" type="string" required>
The access key returned from wallet creation. Retrieve from your database.
</ParamField>

<ParamField body="wallet_id" type="string" required>
The wallet UUID returned from wallet creation.
</ParamField>

<ResponseField name="data.signature" type="string">
The signature in base64 format
</ResponseField>

### Reveal Private Key

Enable a user to reveal their raw private key using RSA encryption.

#### Using Magic's iframe

```javascript JavaScript icon="square-js"
import { Magic } from 'magic-api-wallet';

const magic = new Magic()

// fetch PEM Base64 encoded RSA public key from iframe
const rsaPublicKey = await magic.wallet.getRSAPublicKey();

// send rsa_public_key to your backend service to be relayed to TEE API
const encryptedPrivateKey = await HttpService.BackendService.Post(
  Endpoint.BackendService.RevealPrivateKey,
  { authorization: `Bearer ${access_token}` },
  { rsa_public_key: rsaPublicKey },
);

// unwrap and render private key in secure iframe
await magic.wallet.unwrapPrivateKey(encryptedPrivateKey.privateKey);
```

#### Custom RSA Implementation

```javascript JavaScript icon="square-js"
// Step 1: Create RSA encryption keypair using the Web Crypto API
const keyPair = await window.crypto.subtle.generateKey(
  {
    name: 'RSA-OAEP',
    modulusLength: 4096,
    publicExponent: new Uint8Array([1, 0, 1]),
    hash: 'SHA-1',
  },
  false, // non-exportable from the browser (important)
  ['encrypt', 'decrypt'],
);

// Step 2: Export the raw public key
const exported = await window.crypto.subtle.exportKey('spki', keyPair.publicKey);

// Step 3: Convert the ArrayBuffer to a Base64 string
const exportedAsString = String.fromCharCode(...new Uint8Array(exported));
const exportedAsBase64 = window.btoa(exportedAsString);

// Step 4: Split the Base64 string into manageable chunks
const maxLineLength = 64;
let formattedBase64 = '';
for (let i = 0; i < exportedAsBase64.length; i += maxLineLength) {
  formattedBase64 += exportedAsBase64.slice(i, i + maxLineLength) + '\n';
}

// Step 5: Create the PEM header and footer
const rsa_public_key = `-----BEGIN PUBLIC KEY-----\n${formattedBase64}-----END PUBLIC KEY-----\n`;

// Step 6: Send rsa_public_key to backend to call /v1/api/wallet/reveal_pk
// Step 7: Use the RSA private key to decrypt the encrypted_private_key
const encryptedBuffer = base64ToUint8(encryptedKey);
const decryptedBuffer = await window.crypto.subtle.decrypt(
  { name: 'RSA-OAEP' },
  keypair.privateKey,
  encryptedBuffer,
);
const eoa_pk = new TextDecoder().decode(decryptedBuffer);
```
```bash cURL icon="square-terminal"
curl -X POST 'https://tee.magiclabs.com/v1/api/wallet/reveal_pk' \
  -H 'Content-Type: application/json' \
  -H 'x-magic-secret-key: sk_live_XXXXXXXX' \
  -d '{
    "encryption_context": "hashed_passcode",
    "access_key": "key_shard",
    "wallet_id": "wallet_id",
    "rsa_public_key": "rsa_public_key"
  }'
```

```json
{
  "data": {
    "encrypted_private_key": "encrypted_key_data"
  }
}
```
<ParamField body="rsa_public_key" type="string" required>
PEM Base64 encoded RSA public key
</ParamField>

<ParamField body="encryption_context" type="string" required>
The encryption context used to decrypt key shards. Must match the context used during wallet creation.
</ParamField>

<ParamField body="access_key" type="string" required>
The access key returned from wallet creation. Retrieve from your database.
</ParamField>

<ParamField body="wallet_id" type="string" required>
The wallet UUID returned from wallet creation.
</ParamField>

<ResponseField name="data.encrypted_private_key" type="string">
Private key encrypted by RSA public key sent to the endpoint and can only be decrypted by owner of RSA private key
</ResponseField>

### Wallet Recovery

Recover a wallet using the recovery key when the original `encryption_context` is lost.
```bash cURL icon="square-terminal"
curl -X POST 'https://tee.magiclabs.com/v1/api/wallet/recovery/confirm' \
  -H 'Content-Type: application/json' \
  -H 'x-magic-secret-key: sk_live_XXXXXXXX' \
  -d '{
    "wallet_id": "wallet_id",
    "encryption_context": "hashed_passcode",
    "recovery_key": "recovery_key"
  }'
```

```json
{
  "data": {
    "id": "e982b4a3-14d3-4d66-a3ac-fadfc3ae1875",
    "recovery_key": "f41c504489531934a147413865913f24",
    "access_key": "c6b2565c12a24b1e86f23e2196486541",
    "network": "ETH",
    "wallet_group_id": "58a08494-3c83-439a-8a07-551f2...",
    "metadata": {
      "resource_id": "customer-resource-id"
    },
    "time_created": 1709931542,
    "time_updated": 1809931542
  }
}
```
<ParamField body="wallet_id" type="string" required>
The wallet UUID returned from wallet creation.
</ParamField>

<ParamField body="encryption_context" type="string" required>
The new encryption context to be applied to the recovered wallet's key shards.
</ParamField>

<ParamField body="recovery_key" type="string" required>
The recovery key returned from wallet creation. Retrieve from your database.
</ParamField>

<ResponseField name="data.id" type="string">
The identifier of the recovered wallet.
</ResponseField>

<ResponseField name="data.recovery_key" type="string">
New recovery key for future recovery operations. Update your database with this value.
</ResponseField>

<ResponseField name="data.access_key" type="string">
New access key for non-recovery operations. Update your database with this value.
</ResponseField>

<Warning>
Recovery operations update all key shards. Ensure you update your database with the new `recovery_key` and `access_key` values returned from this operation.
</Warning>

## Error Handling

Core API uses standard HTTP status codes and returns detailed error information to help you troubleshoot issues.

### Common Error Responses

#### 400 Bad Request

**`INVALID_REQUEST_FIELDS`**
- **Cause**: Missing or invalid required fields in the request body
- **Solution**: Verify all required parameters are present and properly formatted

**`MISSING_REQUIRED_HEADER`**
- **Cause**: The `x-magic-secret-key` header is missing from the request
- **Solution**: Include the header: `x-magic-secret-key: sk_live_XXXXXXXX`

**`INVALID_API_KEY`**
- **Cause**: The provided secret key is invalid or expired
- **Solution**: Verify your secret key is correct and your application is allowlisted

**`INVALID_USER_PASSCODE`**
- **Cause**: The `encryption_context` or `access_key` is incorrect
- **Solution**: Ensure the `encryption_context` matches what was used during wallet creation

#### 403 Forbidden

**`METHOD_NOT_AVAILABLE`**
- **Cause**: The requested endpoint or method is not available for your application
- **Solution**: Contact Magic support to enable the required functionality

#### 408 Timeout

**`REQUEST_TIMEOUT`**
- **Cause**: The request took too long to process
- **Solution**: Retry the request or contact support if the issue persists

#### 500 Internal Server Error

**`INTERNAL_SERVER_ERROR`**
- **Cause**: An unexpected error occurred on Magic's servers
- **Solution**: If this error persists, contact Magic support for assistance

### Error Response Format

All error responses follow this format:

**Response:**

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error description",
    "details": "Additional context or troubleshooting information"
  }
}
```

### Best Practices

<Tip>
Always implement proper error handling in your application:
- Check HTTP status codes before processing responses
- Log error details for debugging
- Implement retry logic for transient errors (5xx status codes)
- Provide meaningful error messages to your users
</Tip>

<Warning>
Never expose sensitive error details (like secret keys or encryption contexts) to end users. Log them securely for debugging purposes only.
</Warning>
