---
title: Alchemy Account Abstraction
---

Alchemy’s Account Abstraction tooling makes it possible to quickly spin up Smart Contract Accounts tied to your Magic wallet. The guide below walks through adding account abstraction to a simple Magic project using Alchemy. We’ll leverage a project pointed at the Ethereum Sepolia test network, but you can use any network supported by both Magic and Alchemy. The code snippets provided are based on a Next.js web app but can be modified to work with virtually any JavaScript framework.

You can view the full example on [github](https://github.com/magiclabs/example-evm-account-abstraction) or [codesandbox](https://codesandbox.io/p/devbox/github/magiclabs/example-alchemy-account-abstraction).

### Project prerequisites

To follow along with this guide, you’ll need two things:

1.  A Magic **Publishable** API Key
2.  Alchemy RPC URL
3.  A web client

You can get your **Publishable** API Key from your [Magic Dashboard](https://dashboard.magic.link).

You can get your Alchemy RPC URL (for Ethereum Sepolia) from your [Alchemy Dashboard](https://dashboard.alchemy.com/).

We’ll use the `make-scoped-magic-app` CLI tool to bootstrap a Next.js app with Magic authentication already baked into the client. You’re welcome to use your own client, but this tutorial and its accompanying code snippets assume the output of the `make-scoped-magic-app` CLI as the starting point.

The `make-scoped-magic-app` CLI tool is an easy way to bootstrap new projects with Magic. To get started, simply run the command below in the shell of your choice. Be sure to replace `<PUBLISHABLE_API_KEY>` with the **Publishable** API Key from your [Magic Dashboard](https://dashboard.magic.link).

```bash
npx make-scoped-magic-app \
    --template nextjs-dedicated-wallet \
    --network ethereum-sepolia \
    --login-methods EmailOTP \
    --publishable-api-key <YOUR_PUBLISHABLE_API_KEY>
```

This will bootstrap the starting point of the tutorial for you. In the scaffolded project, be sure to add your Magic Publishable API Key and Alchemy RPC URL to the `.env` as `NEXT_PUBLIC_MAGIC_API_KEY` and `NEXT_PUBLIC_SEPOLIA_RPC`, respectively.

```bash
# Publishable API Key found in the Magic Dashboard
NEXT_PUBLIC_MAGIC_API_KEY=pk_live_1234567890

# The RPC URL for the blockchain network
NEXT_PUBLIC_BLOCKCHAIN_NETWORK=ethereum-sepolia

# The Alchemy RPC URL for the blockchain network
NEXT_PUBLIC_SEPOLIA_RPC=https://eth-sepolia.g.alchemy.com/v2/{ALCHEMY_API_KEY}
```

### Install additional project dependencies

In addition to the packages included in the scaffold produced by the `make-scoped-magic-app` CLI, you’ll need a number of packages related to Alchemy and their account abstraction tools. You’ll also need to install `viem` for EVM-related types and transaction convenience methods. You may need a specific version of `viem` to work properly with the Alchemy packages. At the time of writing, we’re using `1.16.0`.

Run the following command to install the required dependencies:

<Tabs>
<Tab title="NPM">
```bash
npm install @alchemy/aa-accounts @alchemy/aa-alchemy @alchemy/aa-core viem@\^1.16.0
```
</Tab>
<Tab title="Yarn">
```bash
yarn add @alchemy/aa-accounts @alchemy/aa-alchemy @alchemy/aa-core viem@\^1.16.0
```
</Tab>
</Tabs>

### Initialize Alchemy smart contract accounts

Inside of `src/components`, create a directory named `alchemy`. Inside that directory create a file named `useAlchemyProvider.tsx`.

This file will contain a hook that will surface the Alchemy Provider to the rest of the app. It’ll also observe when users log in or out and connect and disconnect to the corresponding smart contract account accordingly. We’ll go through each of these three separately, then show the code for the entire file.

### Initialize `AlchemyProvider`

To initialize the `AlchemyProvider`, call the constructor with the following arguments:

1.  `chain` \- The chain to point to. We’ll be using Sepolia
2.  `entryPointAddress` \- The entry point address is the ERC-4337 contract that enables account abstraction. In our case, we’ll be using the one provided by Alchemy, which you can hardcode as `0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789`.
3.  `rpcUrl` \- The RPC URL from your Alchemy Sepolia project

### Connect to smart contract account

When a user logs in with Magic, we need to associate their Magic account with a smart contract account through Alchemy. Just as Magic handles the creation of user wallets, Alchemy handles the creation of smart contract accounts associated with the wallet. You do this with the `LightSmartContractAccount` from the `@alchemy/aa-accounts` package. You’ll need to pass it the following:

1.  `rpcClient` \- This should be the provider initialized previously
2.  `owner` \- The account owner; in this case you initialize a `WalletClientSigner` using the RPC provider from `magic`
3.  `chain` \- The chain to use. It should be the same one used to initialize the Alchemy Provider.
4.  `entryPointAddress` \- The ERC-4337 contract that enables account abstraction. It should be the same one used to initialize the Alchemy Provider.
5.  `factoryAddress` \- The address that facilitates the creation of new wallet contracts. You can get this with the `getDefaultLightAccountFactoryAddress` helper function from `@alchemy/aa-accounts`.

Below is an example of how to connect to a Magic user’s smart contract account:

```typescript TypeScript icon="square-js"
const lightAccountFactoryAddress = getDefaultLightAccountFactoryAddress(chain)

const magicSigner: SmartAccountSigner | undefined = useMemo(() => {
  if (!magic) return

  const client = createWalletClient({
    transport: custom(magic.rpcProvider),
  })

  return new WalletClientSigner(client as any, "magic")
}, [magic])

provider.connect((provider) => {
  return new LightSmartContractAccount({
    rpcClient: provider,
    owner: magicSigner,
    chain,
    entryPointAddress,
    factoryAddress: lightAccountFactoryAddress,
  })
})

```

### Disconnect from smart contract account

When a user logs out, you’ll need to disconnect from their smart contract account. This is as simple as calling `provider.disconnect()` and handling necessary state changes.

### Completed `useAlchemyProvider` code

When we put all of this together, we get the following:

```typescript TypeScript icon="square-js"
import {
  getDefaultLightAccountFactoryAddress,
  LightSmartContractAccount,
} from "@alchemy/aa-accounts"
import { SmartAccountSigner, WalletClientSigner } from "@alchemy/aa-core"
import { AlchemyProvider } from "@alchemy/aa-alchemy"
import { sepolia } from "viem/chains"
import { createWalletClient, custom, WalletClient } from "viem"
import { useCallback, useEffect, useMemo, useState } from "react"
import { useMagic } from "../magic/MagicProvider"

// Initializes the useAlchemyProvider hook for managing AlchemyProvider in a React component.
export const useAlchemyProvider = () => {
  const chain = sepolia
  const lightAccountFactoryAddress = getDefaultLightAccountFactoryAddress(chain)
  const entryPointAddress = useMemo(
    () => "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
    []
  )
  const { magic } = useMagic()
  const [provider, setProvider] = useState<AlchemyProvider>(
    new AlchemyProvider({
      chain,
      entryPointAddress,
      rpcUrl: process.env.NEXT_PUBLIC_SEPOLIA_RPC!,
    })
  )

  const magicSigner: SmartAccountSigner | undefined = useMemo(() => {
    if (!magic) return

    const client = createWalletClient({
      transport: custom(magic.rpcProvider),
    })

    return new WalletClientSigner(client as any, "magic")
  }, [magic])

  useEffect(() => {
    if (magic?.user.isLoggedIn) {
      connectToSmartContractAccount()
    } else {
      disconnectFromSmartContractAccount()
    }
  }, [magic?.user.isLoggedIn])

  // Connects the AlchemyProvider to a Smart Account using the LightSmartContractAccount class.
  // Sets the owner as the Magic account wallet
  const connectToSmartContractAccount = useCallback(() => {
    if (!magicSigner) return

    // This is where Magic is associated as the owner of the smart contract account
    const connectedProvider = provider.connect((provider) => {
      return new LightSmartContractAccount({
        rpcClient: provider,
        owner: magicSigner,
        chain,
        entryPointAddress,
        factoryAddress: lightAccountFactoryAddress,
      })
    })

    setProvider(connectedProvider)
    return connectedProvider
  }, [entryPointAddress, provider])

  // Disconnects the AlchemyProvider from the current account.
  const disconnectFromSmartContractAccount = useCallback(() => {
    const disconnectedProvider = provider.disconnect()
    setProvider(disconnectedProvider)
    return disconnectedProvider
  }, [provider])

  // Returns the AlchemyProvider for use in components.
  return {
    provider,
  }
}
```

### Update UI Components

Now that the project successfully creates and connects to users’ smart contract accounts with Alchemy, we can update the UI to show the smart contract address, its balance, and enable sending transactions from the smart contract account. These changes take place in the `UserInfoCard` and the `SendTransactionCard`.

### Update `UserInfoCard`

### Update state items

First things first. Open `src/components/magic/cards/UserInfoCard.tsx` and change the state declaration of `balance`, `setBalance`, and `publicAddress` to `magicBalance`, `setMagicBalance`, and `magicAddress`. While you’re at it, add a state declaration for `scaBalance`, `setScaBalance`, `scaAddress`, and `setScaAddress` to store the smart contract account balance and address.


```typescript TypeScript icon="square-js"
// Change this
const [balance, setBalance] = useState("...")
const [publicAddress] = useState(
  localStorage.getItem("user")
)

// To this
const [magicBalance, setMagicBalance] = useState<string>("...")
const [scaBalance, setScaBalance] = useState<string>("...")
const [magicAddress] = useState(
  localStorage.getItem("user")
)
const [scaAddress, setScaAddress] = useState<string>("")
```


### [#Update `getBalance`](#update-get-balance)

Next, update the `getBalance` function to set both balances:



```typescript TypeScript icon="square-js"
const getBalance = useCallback(async () => {
  if (magicAddress && web3) {
    const magicBalance = await web3.eth.getBalance(magicAddress)
    if (magicBalance == BigInt(0)) {
      setMagicBalance("0")
    } else {
      setMagicBalance(web3.utils.fromWei(magicBalance, "ether"))
    }
  }
  if (scaAddress && web3) {
    const aaBalance = await web3.eth.getBalance(scaAddress)
    if (aaBalance == BigInt(0)) {
      setScaBalance("0")
    } else {
      setScaBalance(web3.utils.fromWei(aaBalance, "ether"))
    }
  }
}, [web3, magicAddress, scaAddress])
```

### Update balance display

Next, update the TSX for displaying the balance to show both balances:


```typescript TypeScript icon="square-js"
<div className="flex flex-col gap-2">
  <div className="code">
    Magic: {magicBalance.substring(0, 7)} {getNetworkToken()}
  </div>
  <div className="code">
    AA: {scaBalance.substring(0, 7)} {getNetworkToken()}
  </div>
</div>
```


### Update initial balances

The only remaining balance reference is to set the initial balance while loading to `"..."`. This is in a short `useEffect` that calls `setBalance`. Update this `useEffect` to set both balances:

```typescript TypeScript icon="square-js"
// Change this
useEffect(() => {
  setBalance('...');
}, [magic]);

// To this
useEffect(() => {
  setMagicBalance("...")
  setScaBalance("...")
}, [magic])
```

### Set `scaAddress`

```typescript TypeScript icon="square-js"
const { provider } = useAlchemyProvider()

const getSmartContractAccount = useCallback(async () => {
  const aaAccount = await provider.account?.getAddress()
  setScaAddress(aaAccount as `0x${string}`)
}, [provider])

useEffect(() => {
  getSmartContractAccount()
}, [provider, provider.account, getSmartContractAccount])
```


### Update address display

Now find the `CardLabel` and div that displays the address and modify it to use the new naming for `magicAddress` and also display the `scaAddress`.

```typescript TypeScript icon="square-js"
<CardLabel
  leftHeader="Addresses"
  rightAction={
    !magicAddress ? <Spinner /> : <div onClick={copy}>{copied}</div>
  }
/>
<div className="flex flex-col gap-2">
  <div className="code">
    Magic:{" "}
    {magicAddress?.length == 0 ? "Fetching address..." : magicAddress}
  </div>
  <div className="code">
    Smart Contract Account:{" "}
    {scaAddress?.length == 0 ? "Fetching address..." : scaAddress}
  </div>
</div>
```

Now when a user logs in using Magic, both their Magic and smart contract account address and balances will be displayed!

## Update `SendTransactionCard`

To send a transaction from your smart contract account, you will need to initiate a transaction by calling the `sendUserOperation` method on the Alchemy `provider` object. This transaction requires the following arguments:

1.  `target` \- The recipient’s wallet address
2.  `data` \- Data associated with the transaction. Since we’re just transferring tokens, there is no data and you should put `"0x"`
3.  `value` \- the amount of tokens to send in `wei`.

The hash returned from `sendUserOperation` is not the User Operation Receipt, rather a proof of submission. We call the `waitForUserOperationTransaction` function, which will return the User Operation Receipt once the transaction has been bundled, included in a block and executed on-chain.

In `src/components/magic/cards/SendTransactionCard.tsx`, import the the `provider` from `useAlchemyProvider` hook and replace the code for `sendTransaction` with the code below.


<Note>
To transfer funds from your smart contract account, ensure you have enough test tokens to send. You can get some test Sepolia tokens [here](https://sepoliafaucet.com/).
</Note>

```typescript TypeScript icon="square-js"
const sendTransaction = useCallback(async () => {
    if (!web3?.utils.isAddress(toAddress)) {
      return setToAddressError(true);
    }
    if (isNaN(Number(amount))) {
      return setAmountError(true);
    }
    setDisabled(true);

    const result = await provider.sendUserOperation({
      target: toAddress as `0x${string}`,
      data: "0x",
      value: web3.utils.toWei(amount, 'ether'),
    });

    const txHash = await provider.waitForUserOperationTransaction(result.hash)
      .then((receipt) => {
        showToast({
          message: `Transaction Successful. TX Hash: ${receipt}`,
          type: 'success',
        });
        setHash(receipt);
        setToAddress('');
        setAmount('');
        console.log('Transaction receipt:', receipt);
      })

    console.log(txHash);
    setDisabled(false);
  }, [web3, amount, publicAddress, toAddress]);
```

Thats it! You’ve just transferred tokens from your newly created smart contract account!

**Next Steps**

You now know how to integrate Magic with a smart contract account and include the following features:

1.  Simple authentication with Email OTP
2.  Automatic smart contract account creation for first-time users
3.  Ability to have Magic users interact with their smart contract accounts
4.  Transfer funds from your smart contract account

Feel free to take a look at our [final solution code](https://github.com/magiclabs/example-evm-account-abstraction) or tinker with it directly in [Codesandbox](https://codesandbox.io/p/devbox/github/magiclabs/example-alchemy-account-abstraction). Take a look at the Alchemy [smart account](https://accountkit.alchemy.com/smart-accounts/overview.html) docs for more information on what is possible with Magic and smart accounts.


